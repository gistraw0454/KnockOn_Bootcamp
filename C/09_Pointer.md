# ? 09. 포인터
## ? C언어 포인터?
1. **포인터의 기본개념과 용도**
- 메모리의 주소값을 저장하는 변수, 포인터 변수라고도 부른다
- char형 변수가 문자를 저장하고, int형 변수가 정수를 저장하는 것 처럼 포인터는 주소값을 저장한다,
- 포인터 용도
    - 연결된 자료구조를 구축하기위해
    - 동적으로 할당된 자료구조를 지칭하기위해
    - Call by Reference 의 호출을 구현하기위해
    - 자료구조안의 요소에 접근하고 요소들을 훑어나갈때
    - 배열을 인수로 전달하여 매개변수로 받을때
    - 함수를 참조하기위해
    - 문자열을 표현하기위해
    - 시스템 메모리에 직접 접근하기 위해
2. **포인터를 사용하는 이유와 장점**
- 포인터를 사용하는 이유 
    > 간결하고 효율적 처리가능. 더 빠른 기계어 코드생성. 배열 및 구조체 등에 쉬운접근. 포인터에 대한 호출 call by reference 가능. 동적 객체 취급
    - C언어는 메모리에 접근해 우리가 원하는 방식으로 데이터를 사용할 수 있게 해주는 언어다.
    - 변수를 사용해 메모리에 접근을 하려면 변수 선언으로 메모리에 공간을 확보하고, 그곳을 데이터가 넣고 꺼내 쓰는 공간으로 사용한다.
    - 변수를 사용하는 가장 쉬운방법이 이름을 쓰는것이고, 이 변수명은 메모리공간을 식별하는 역할을 한다.
        - 함수내부에서만 그변수를 사용할 수 있고, 같은 변수명을 사용한다 하더라도 블록이나 함수가 다르면 별도의 저장공간을 확보하므로 전혀 다른 변수로 사용된다.
    - 변수 대신 메모리 주소값을 이요해 메모리에 접근하는 포인터를 사용하면, 사ㅓ용범위를 벗어난 경우도 데이터를 공유할 수 있다.
- 포인터 사용 장점
    - 메모리 주소를 참조해서 다양한 자료형 변수들의 접근과 조작이 용이
    - call by reference 에 의한 전역변수 사용억제
    - 배열과 같은 연속 데이터에 접근과 조작이 용이
    - 메모리에 직접 접근가능

3. **포인터의 선언과 사용방법**
- `type* ptr`
    - 포인터 변수 ptr은 type형 변수의 주소 값을 저장한다
- `ptr = &a` 주소로 초기화
- `*` 연산자
    - 포인터가 가리키는 메모리 공간의 접근을 의미
- 포인터는 메모리 주소이고, 포인터 변수에 직접 숫자 상수를 대입하여 초기화 할 수는 없다.
    - <포인터 변수에 대입할 수 있는 값>
    - NULL
    - 다른 변수의 주소나 배열명, 함수명
    - malloc 이나 calloc함수에 의해 반환되는 주소값
4. **포인터와 배열 사이의 관계**
- 배열의 각 원소들은 메모리 상에 연속적으로 위치해 있게된다.
- *(p+1) == arr[1]
- p+1 == &arr[1]
- 포인터배열
    - 배열의 요소가 포인터
    - char* arr[3];
- 배열포인터
    - 특정사이즈의 배열만 가리킬 수 있는 <ins>하나의 포인터</ins>
    - char (*arr)[3];
5. **Call by Value, Call by Reference**
- 값에 의한 호출, 참조에 의한 호출
- Call by value 
    - 함수 호출시 넘기는 인자값이 매개변수에 복사돼서 함수내에서 매개변수에 직접적인 데이터 조작을 가해도 인자에 전혀 영향을 주지 않는다.
        - 지역변수, 매개변수가 stack에 할당되기 때문
- Call by reference
    - 인자(변수의주소)의 값이 매개변수(포인터 변수로 정의된 매개변수)에 복사된다. 복사되는 값이 데이터의 주소값이라는 차이가 있다.
    - 참조값으로 함수를 호출했다.
6. **이중 포인터**
- 포인터도 변수이므로 메모리 상의 공간에 저장되어있고 주소값을 가진다.
- 이 포인터의 주소값을 가지는 포인터 ==> 포인터의 포인터 (이중포인터)
- 포인터의 포인터는(**p) 포인터를 가리키고 있는거다.
    ```c
    #include <stdio.h>
    int main() {
        int a;
        int *pa;
        int **ppa;

        pa = &a;
        ppa = &pa;
        a = 3;
        
        printf("%d %d %d\n", a, *pa, **ppa);
        printf("%d %d %d\n", &a, pa, *ppa);
        printf("%d %d", &pa, ppa);
        
        return 0;
    }
    //3 3 3
    //6487572 6487572 6487572
    //6487560 6487560
    ```

## ? 코드 분석
```c
// Call by Value, Call by Reference 개념을 생각하며 다음과 같은 코드를 이해해봅시다.
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    printf("x: %d, y: %d\\n", x, y);
    swap(&x, &y);
    printf("x: %d, y: %d\\n", x, y);
    return 0;
}

```

- call by reference에 의하여, x와 y의 주소값이 인자값으로 매개변수로 전달된다. 
- 이때 매개변수는 포인터 변수로 선언된다. 따라서 함수내에서도 값이 swap된다.

```c
// 아래의 코드의 실행 결과를 예상하여 봅시다
int main() {
	char m[] = "ABC";
	char* ap = m;
	*ap++ += 1;		
	*++ap += 3;		
	ap -= 2;		
	ap[1] += 2;		
	puts(m);		
}
```

- 포인터변수 ap에 m의 주소가 들어가있다.
- *ap++ +=1;
    - (\*ap) = (\*ap)+1 하여 A를 B로 바꿔주고, ap++ 해줘서 인덱스를 m[1]로 바꿔준다.
- *++ap +=3;
    - ++ap 해줘서 인덱스를 m[2]부분으로 바꿔준 후, *ap +=3 을 해줘서 C를 F로 바꿔준다.
- ap-=2;
    - 인덱스를 m으로 바꿔주고
- ap[1] +=2;
    - ap[1]의 B를 D로 바꿔준다.
- puts(m);
    BDF를 출력한다.

```c
// 아래의 코드의 실행 결과를 예상하여 봅시다
int main() {
	short m[2][2] = { {10,20},{30,40} };
	short a, sum = 0;
	*m[0] = 15;
	*(m[0] + 1) = 25;
	*m[1] = 35;
	m[0][3] = 45;
	
	**m = 17;
	*(*(m + 1) + 1) = 47;
	*(*m + 1) = 27;
	**(m + 1) = 37;
	m[1][-1] += 2;
	for ( a = 0; a < 4; a++)
	{
		sum += m[0][a];
	}

	printf("%d\n", sum);
}
```

- *m[0] = 15;
    - {{15,20},{30,40}}
- *(m[0]+1)=25;
    - {{15,25},{30,40}}
- *m[1]=35;
    - {{15,25},{35,40}}
- m[0][3]=45;
    - {{15,25},{35,45}}
- \*\*m = 17;
    - {{17,25},{35,45}}
- \*(\*m + 1) = 27;
    - {{17,27},{35,45}}
- \*\*(m + 1) = 37;
    - {{17,27},{37,45}}
- m[1][-1] += 2;
    - {{17,29},{37,45}}
- sum으로 130이 출력된다.


## ? Challenge !
- **1번째 예시를 이용하여 배열의 순서를 섞는 shuffle() 함수를 작성해 보기. (반드시 swap() 함수를 이용해야 함!)**

ex)

Array : 1 2 3 4 5

===shuffle===

Array : 5 3 2 1 4

```c
#include <stdio.h>

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void shuffle(int* arr) {
    for (int i = 0; i < 4; i++) { 
        swap(&arr[4-i], &arr[3-i]);
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5}; 

    shuffle(arr);
    
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}
```